<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Regex Tutorial</title>
</head>
<body>
    <header>
        <h1>Regex Tutorial</h1>
        <p>Welcome to the Regex Tutorial! This guide will help you understand and master regular expressions.</p>
    </header>
    <section id="overview">
        <h2>Overview</h2>
        <p>In this tutorial, we'll explore a powerful regex pattern and break down its components.</p>
    </section>
    <nav>
        <h2>Table of Contents</h2>
        <ul>
            <li>Introduction to Regular Expressions</li>
            <p>Literals:
                Definition: Literals are characters that match themselves. In a regex, any alphanumeric character, such
                as letters or numbers, is treated as a literal.
                Example: The regex a will match the character 'a' in a string.
                Metacharacters:

                Definition: Metacharacters are special characters in a regex that have a reserved meaning and are used
                to define the structure of a pattern.
                Common Metacharacters:
                . (Dot): Matches any character except a newline.
                ^ (Caret): Anchors the regex at the beginning of a line.
                $ (Dollar): Anchors the regex at the end of a line.
                * (Asterisk): Matches zero or more occurrences of the preceding element.
                + (Plus): Matches one or more occurrences of the preceding element.
                ? (Question Mark): Matches zero or one occurrence of the preceding element.
                | (Pipe): Acts as an OR operator, allowing for alternatives.</p>

            <li>Anchors</li>
            <p>Anchors in regular expressions are used to specify the position of a match within a string. They do not
                match characters themselves but rather positions within the text. Here are the commonly used anchors:

                ^ (Caret) - Start of Line Anchor:

                Definition: This anchor asserts that the following regex pattern must appear at the beginning of a line.
                Example: ^Hello will match any string that starts with "Hello."
                $ (Dollar) - End of Line Anchor:

                Definition: This anchor asserts that the preceding regex pattern must appear at the end of a line.
                Example: World$ will match any string that ends with "World."
                \b - Word Boundary Anchor:

                Definition: The word boundary anchor matches a position where a word starts or ends. It does not consume
                any characters.
                Example: \bword\b will match the word "word" but not "password" or "words."
                \B - Non-Word Boundary Anchor:

                Definition: The non-word boundary anchor is the opposite of \b. It matches a position that is not a word
                boundary.
                Example: \Bword\B will match "password" but not "word" or "words."
                (?m) - Multiline Mode:

                Definition: This is a mode modifier, not a typical anchor. It changes the behavior of ^ and $ to match
                the start and end of each line in a multiline string.
                Example: ^(?m)start will match "start" at the beginning of any line in a multiline string.</p>
            <li>Quantifiers</li>
            <p>Definition: Quantifiers modify the number of occurrences of the preceding element.
                Common Quantifiers:
                *: Matches zero or more occurrences.
                +: Matches one or more occurrences.
                ?: Matches zero or one occurrence.
                {n}: Matches exactly n occurrences.
                {n,}: Matches n or more occurrences.
                {n,m}: Matches between n and m occurrences.</p>
            <li>Character Classes</li>
            <p>Definition: Character classes allow you to match any one of a set of characters.
                Common Character Classes:
                [abc]: Matches 'a', 'b', or 'c'.
                [0-9]: Matches any digit from 0 to 9.
                [^A-Za-z]: Matches any character that is not an uppercase or lowercase letter.</p>
            <li>Grouping and Capturing</li>
            <p>Grouping and capturing are essential concepts in regular expressions that allow you to define and extract
                portions of a matched pattern. By using parentheses (), you can create groups within your regex pattern.
                Here's an explanation of grouping and capturing:

                Grouping (()):

                Definition: Parentheses are used to create groups within a regex pattern. A group can contain one or
                more characters or sub-patterns.
                Example:
                (ab)+ matches one or more occurrences of the sequence "ab."
                (red|blue) matches either "red" or "blue."
                Capturing Groups (( and )):

                Definition: Capturing groups not only group the matched characters but also capture the text matched by
                the enclosed pattern. The captured text can be referenced later or used in replacements.
                Example:
                (\d{2})/(\d{2})/(\d{4}) can capture day, month, and year components in a date pattern like "12/31/2022."
                Backreferences:

                Definition: After capturing a group, you can reference the captured text later in the regex or in
                replacement patterns.
                Example:
                \b(\w+)\s+\1\b matches repeated words separated by whitespace. Here, \1 references the text captured by
                the first capturing group.
                Non-Capturing Groups ((?:)):

                Definition: Sometimes you want to group elements without capturing them. You can use (?:) to create
                non-capturing groups.
                Example:
                (?:Mr|Ms|Mrs)\. (\w+) matches titles like "Mr. Smith" but only captures the name.
                Named Capturing Groups (?<name>...):

                    Definition: Modern regex engines support naming capturing groups, making it easier to reference
                    captured text.
                    Example:
                    (?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2}) captures and names year, month, and day components in a
                                date pattern.
            </p>
            <li>Assertions</li>
            Assertions in regular expressions are used to specify conditions that must be met for a match to occur. They
            do not consume characters in the string but rather assert whether a certain condition is true at a
            particular position. There are both positive and negative assertions. Here are some common assertions:

            ^ (Caret) - Start of Line Assertion:

            Definition: Asserts that the following pattern must occur at the beginning of a line.
            Example: ^Start matches "Start" only if it appears at the beginning of a line.
            $ (Dollar) - End of Line Assertion:

            Definition: Asserts that the preceding pattern must occur at the end of a line.
            Example: End$ matches "End" only if it appears at the end of a line.
            \b - Word Boundary Assertion:

            Definition: Asserts that the following pattern must occur at a word boundary.
            Example: \bWord\b matches "Word" only if it appears as a whole word.
            \B - Non-Word Boundary Assertion:

            Definition: Asserts that the following pattern must not occur at a word boundary.
            Example: \Bword\B matches "password" but not "word" or "words."
            (?=...) - Positive Lookahead Assertion:

            Definition: Asserts that the enclosed pattern must match at the current position in the string, without
            consuming characters.
            Example: foo(?=bar) matches "foo" only if it is followed by "bar."
            (?!...) - Negative Lookahead Assertion:

            Definition: Asserts that the enclosed pattern must not match at the current position in the string.
            Example: foo(?!bar) matches "foo" only if it is not followed by "bar."
            (?<=...) - Positive Lookbehind Assertion: Definition: Asserts that the enclosed pattern must match
                immediately before the current position in the string. Example: (?<=\$)\d+ matches one or more digits
                preceded by a dollar sign. (?<!...) - Negative Lookbehind Assertion: Definition: Asserts that the
                enclosed pattern must not match immediately before the current position in the string. Example:
                (?<!\d+)\bword\b matches "word" only if it is not preceded by digits. <li>Character Escapes</li>
                <p>Character escapes in regular expressions are used to represent characters that have special meaning
                    or are difficult to represent directly. By using a backslash \ followed by a specific character, you
                    can create an escape sequence. Here are some common character escapes:

                    \n - Newline:

                    Usage: Represents a newline character.
                    Example: This is the first line.\nThis is the second line.
                    \t - Tab:

                    Usage: Represents a tab character.
                    Example: Column1\tColumn2\tColumn3
                    \r - Carriage Return:

                    Usage: Represents a carriage return character.
                    Example: Before\rAfter
                    \d - Digit:

                    Usage: Represents any digit (0-9).
                    Example: \d{3} matches three consecutive digits.
                    \D - Non-Digit:

                    Usage: Represents any non-digit character.
                    Example: \D{2,} matches two or more consecutive non-digits.
                    \w - Word Character:

                    Usage: Represents any word character (alphanumeric + underscore).
                    Example: \w+ matches one or more word characters.
                    \W - Non-Word Character:

                    Usage: Represents any non-word character.
                    Example: \W{3} matches three consecutive non-word characters.
                    \s - Whitespace:

                    Usage: Represents any whitespace character (space, tab, newline).
                    Example: \s{2,} matches two or more consecutive whitespace characters.
                    \S - Non-Whitespace:

                    Usage: Represents any non-whitespace character.
                    Example: \S+ matches one or more non-whitespace characters.
                    \. - Dot:

                    Usage: Represents a literal dot character.
                    Example: www\.example\.com
                    \\ - Backslash:

                    Usage: Represents a literal backslash character.
                    Example: C:\\Users\\Username</p>

                <li>flags</li>
                <p>In regular expressions, flags are modifiers that alter the behavior of the pattern matching. Flags
                    are added to the end of a regular expression and are usually denoted by letters. Different
                    programming languages and regex libraries may use different flag syntax, but some common ones
                    include:

                    i - Case Insensitive:

                    Usage: Ignores the case of the characters while matching.
                    Example: /pattern/i matches "Pattern," "pattern," or "PATTERN."
                    g - Global Search:

                    Usage: Searches for all occurrences of the pattern in the entire string, not just the first one.
                    Example: /pattern/g matches all occurrences of "pattern" in a string.
                    m - Multiline:

                    Usage: Changes the behavior of ^ and $ anchors to match the start and end of each line within a
                    multiline string.
                    Example: /pattern/m matches "pattern" at the start of any line in a multiline string.
                    s - DotAll:

                    Usage: Changes the behavior of the dot (.) to match any character, including newline characters.
                    Example: /pattern/s matches "pattern" even if it spans multiple lines.
                    u - Unicode:

                    Usage: Treats the pattern and the input string as Unicode, enabling support for Unicode characters
                    and properties.
                    Example: /pattern/u matches Unicode characters.
                    y - Sticky:

                    Usage: Requires that the pattern is matched at the start of the string, and subsequent matches start
                    where the previous one left off.
                    Example: /pattern/y matches "pattern" only if it appears at the start of the string.</p>

                <li>The OR Operator</li>
                <p>
                    In regular expressions, the "or" operator is represented by the pipe symbol (|). It functions as a
                    logical OR, allowing you to specify alternative patterns. The regular expression will match if any
                    of the alternatives match. Here's how you can use the "or" operator:</p>

                <li>bracket expression</li>
                <p>A bracket expression, also known as a character class, is a way to specify a set of characters within
                    square brackets [] in a regular expression. It defines a group of characters, and the regular
                    expression engine matches any single character from that defined set. Here are some key points about
                    bracket expressions:

                    Basic Syntax:

                    The basic syntax for a bracket expression is [characters].
                    For example, [abc] matches any single character that is either 'a', 'b', or 'c'.
                    Character Ranges:

                    You can specify a range of characters using a hyphen - inside the square brackets. For example,
                    [a-z] matches any single lowercase letter from 'a' to 'z'.
                    Ranges can also be specified for digits and other character types.
                    Negation:

                    Placing a caret ^ at the beginning of the bracket expression negates it. For example, [^0-9] matches
                    any single character that is not a digit.
                    Special Characters Inside Bracket Expressions:

                    Certain characters inside the bracket expression have special meanings, such as ^, -, ], and \.
                    For example, to include the literal hyphen '-' in the character class, you can place it at the
                    beginning or end of the expression.
                    Combining Characters:

                    You can combine different character classes inside the square brackets. For example, [A-Za-z]
                    matches any single alphabetic character (both uppercase and lowercase).
                    Quantifiers with Bracket Expressions:

                    Quantifiers can be applied to bracket expressions. For example, [0-9]{2} matches any two consecutive
                    digits.
                    Common Use Cases:

                    Bracket expressions are commonly used for specifying character sets in various scenarios, such as
                    validating input or extracting specific patterns from a text.
                    Examples:

                    [0-9]: Matches any single digit.
                    [A-Za-z]: Matches any single alphabetic character (case-sensitive).
                    [^aeiou]: Matches any single character that is not a vowel.
                    [0-9A-Fa-f]: Matches any single hexadecimal digit.</p>
        </ul>
    </nav>
</body>
</html>